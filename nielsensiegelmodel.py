# -*- coding: utf-8 -*-
"""NielsenSiegelModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nNAcJUY60NdG2_rI5OGp4y9cH0QdCmI2
"""

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from datetime import datetime
import ipywidgets as widgets

import warnings

warnings.filterwarnings('ignore')

#def nielsen_siegel_model(t, beta0, beta1, beta2, tau):
#    """
#    Nielsen-Siegel Model Function
#    t: maturities (list/array)
#    beta0, beta1, beta2: model parameters
#    tau: parameter representing the time-to-maturity
#    """
#    return beta0 + beta1 * (1 - np.exp(-t/tau)) / (t/tau) + beta2 * ((1 - np.exp(-t/tau)) / (t/tau) - np.exp(-t/tau))

def nielsen_siegel_model(t, beta0, beta1, beta2, tau):
    term1 = (1 - np.exp(-t / tau)) / (t / tau)
    term2 = term1 - np.exp(-t / tau)
    return beta0 + beta1 * term1 + beta2 * term2

def reconstruct_yield_curve(maturities, beta0, beta1, beta2, tau):
    """
    Reconstruct the yield curve using the Nielsen-Siegel model
    """
    return nielsen_siegel_model(maturities, beta0, beta1, beta2, tau)

def determine_cheap_expensive(yields, reconstructed_yields):
    """
    Determine which bonds are cheap or expensive based on the model
    """
    deviations = yields - reconstructed_yields
    return ['cheap' if deviation < 0 else 'expensive' for deviation in deviations]

def replace_outliers_with_previous_value(series, threshold):
    # Initialize an empty series to hold the processed values
    processed_series = pd.Series(index=series.index, dtype=series.dtype)

    for i in range(len(series)):
      # If the absolute value of the current value is beyond the threshold,
      # replace it with the previous value
      if abs(series[i]) > threshold:
          processed_series[i] = processed_series[i-1]
      else:
          processed_series[i] = series[i]

    return processed_series#.rolling(21).mean()

def plot_yield_curve(beta0, beta1, beta2, tau, maturities):
    # Generate maturities for plotting
    maturities = maturities
    # Calculate yields using the Nielsen-Siegel model
    yields_est = nielsen_siegel_model(maturities, beta0, beta1, beta2, tau)
    # Plot the yield curve
   # Plot the fitted yield curve
    #plt.figure(figsize=(1,6))
    fig, axs = plt.subplots(2, 1, figsize=(18, 8),sharex=True)
    axs[0].plot(maturities, yields, 'bo-', label='Actual Yields')
    axs[0].plot(maturities, yields_est, 'r*-', label='Fitted Yields')
    #axs[0].set_xlabel('Maturity (years)')
    axs[0].set_ylabel('Yield')
    axs[0].set_title('Fitted Yield Curve from Nielsen-Siegel Model')
    axs[0].legend()
    axs[0].grid(True)

    # Plot the difference between actual yields and fitted yields as a bar plot
    yield_difference = (yields - yields_est)*100
    axs[1].bar(maturities, yield_difference, color='g', alpha=0.7)
    axs[1].set_xlabel('Maturity (years)')
    axs[1].set_ylabel('Difference (Actual - Fitted)')
    axs[1].set_title('Difference between Actual Yields and Fitted Yields')
    axs[1].grid(True)

    #plt.tight_layout()
    plt.show()

#yields_data = pd.read_excel('NielsenSiegelInput.xlsx', parse_dates=False, sheet_name='Yields',index_col=0)
#maturities_data = pd.read_excel('NielsenSiegelInput.xlsx', parse_dates=False, sheet_name='Maturities',index_col=0)
bonos=pd.read_excel('Rates.xlsx', parse_dates=True, sheet_name='Bonos',index_col=0)
udis=pd.read_excel('Rates.xlsx', parse_dates=True, sheet_name='Udibonos',index_col=0)
tsy=pd.read_excel('Rates.xlsx', parse_dates=True, sheet_name='TSY',index_col=0)
tips=pd.read_excel('Rates.xlsx', parse_dates=True, sheet_name='TIPS',index_col=0)

#yields_data.index=pd.to_datetime(yields_data.index)
#maturities_data.index=pd.to_datetime(maturities_data.index)
bonos.columns=[1.,2.,3.,4.,5.,10.,15.,20.,30.]
udis.columns=[2.,3.,5.,8.,10.,20.,30.]
tsy.columns=[1/12,0.25,0.5,1.,2.,3.,5.,10.,30.]
tips.columns=[1.,2.,3.,4.,5.,6.,7.,8.,9.,100,20.,30.]

yields_data={'Bonos':bonos,
            'Udis':udis,
            'Tsy':tsy,
            'Tips':tips}

udis

def plot_curve(curve='Bonos'):
  # Example data for maturities and corresponding yields
  global yields
  yields=yields_data[curve].iloc[-1].values
  maturities=yields_data[curve].columns

  initial_guess = (0.01, 0.01, 0.01, 1)  # Initial guess for beta0, beta1, beta2, and tau
  optimal_params, _ = curve_fit(nielsen_siegel_model, maturities, yields, p0=initial_guess)

  # Optimal parameters obtained from curve fitting or other methods
  #optimal_params = (0.02, 0.03, -0.01, 5)  # Example optimal parameters (beta0, beta1, beta2, tau)

  # Reconstruct the yield curve using the Nielsen-Siegel model and optimal parameters
  reconstructed_yields = reconstruct_yield_curve(maturities, *optimal_params)

  # Determine which bonds are cheap or expensive based on the model
  cheap_expensive_status = determine_cheap_expensive(yields, reconstructed_yields)

  # Print results
  #print("Reconstructed Yields:", reconstructed_yields)

  plot_yield_curve_controls = widgets.interactive(plot_yield_curve,
                                        beta0=widgets.FloatSlider(value=optimal_params[0], min=-100, max=100, step=0.1, description='Level:'),
                                        beta1=widgets.FloatSlider(value=optimal_params[1], min=-100, max=1000000, step=0.1, description='Slope:'),
                                        beta2=widgets.FloatSlider(value=optimal_params[2], min=-1000000, max=1000000, step=0.1, description='Curvature:'),
                                        tau=widgets.FloatSlider(value=optimal_params[3], min=0.1, max=100, step=0.1, description='Tau:'),
                                          maturities=widgets.fixed(maturities))
  display(plot_yield_curve_controls)

plot_curve('Bonos')

bounds_dict={'Bonos':([0, -5, -5, 0], [11, 10, 10, 10]),
             'Udis': ([-1, -5, -5, 0], [9, 10, 10, 10]),
             'Tsy': ([-1, -5, -5, 0], [6, 10, 10, 10]),
             'Tips':([-1, -5, -5, 0], [4, 10, 10, 10])}

guess_dict={'Bonos':(9, 0, 0, 1),
             'Udis': (4, 0, 0, 1),
             'Tsy': (4, 0, 0, 1),
             'Tips':(2, 0, 0, 1)}

def historic_params(yields_data, bounds_dict, guess_dict, curve='Bonos'):
  bounds = bounds_dict[curve]  # Example bounds
  yields=yields_data[curve]#.resample('M').last().fillna(method='ffill')
  maturities=yields.columns
  factors=pd.DataFrame()

  for i in yields.index:
    yields_last=np.round(yields.loc[i].values,1)
    #model
    try:
      initial_guess = guess_dict[curve]  # Initial guess for beta0, beta1, beta2, and tau
      optimal_params, _ = curve_fit(nielsen_siegel_model, maturities, yields_last, p0=initial_guess, maxfev=10000, bounds=bounds)

      factors = pd.concat([factors,pd.Series(optimal_params)],axis=1)
    except:
      print(i)
  factors.columns=yields.index
  factors.index=['Level','Slope','Curvature','Tau']
  factors=factors.T

  return factors#.rolling(12).mean().dropna()



factors_bonos=historic_params(yields_data, bounds_dict, guess_dict, curve='Bonos')
for i in factors_bonos.columns:
  factors_bonos[[i]].plot(figsize=(12,6), title=i)
  plt.show()

factors_udis=historic_params(yields_data, bounds_dict, guess_dict, curve='Udis')
for i in factors_udis.columns:
  factors_udis[[i]].plot(figsize=(12,6), title=i)
  plt.show()

yields_data['Udis']



factors_tsy=historic_params(yields_data, bounds_dict, guess_dict, curve='Tsy')
for i in factors_tsy.columns:
  factors_tsy[[i]].plot(figsize=(12,6), title=i)
  plt.show()

factors_tips=historic_params(yields_data, bounds_dict, guess_dict, curve='Tips')
for i in factors_tips.columns:
  factors_tips[[i]].plot(figsize=(12,6), title=i)
  plt.show()

factors['Level'].loc['2018']

print(yields.loc['2012-06-30'].values)
print(yields.loc['2012-06-30'].index)

yields.loc['2012-07-31'].values

initial_guesses = [0.03, -0.02, 0.02, 1.0]
opt,_=curve_fit(nielsen_siegel_model, [1.0, 2.0, 3.0, 4.0, 5.0, 10.0, 15.0, 20.0, 30.0], [4.478, 4.586, 4.666, 4.75 , 4.874, 5.201, 5.737, 5.944, 6.462], p0=initial_guess)
print(opt)

bounds = ([-np.inf, -np.inf, -np.inf, 0], [np.inf, np.inf, np.inf, np.inf])  # Example bounds
opt_params_with_bounds, _ = curve_fit(
    nielsen_siegel_model,  [1.0, 2.0, 3.0, 4.0, 5.0, 10.0, 15.0, 20.0, 30.0], [4.478, 4.586, 4.666, 4.75 , 4.874, 5.201, 5.737, 5.944, 6.462],
    p0=initial_guesses, maxfev=10000,
    bounds=bounds)

print(opt_params_with_bounds)

